package repository
package repository

import (
	"context"
	"database/sql"
	"testing"
	"time"





























































































































































































































































































































































































































































































}	assert.Error(t, err)	err := CheckPassword(wrongPassword, hash)	hash, _ := HashPassword(password)	wrongPassword := "WrongPassword456!"	password := "SecurePassword123!"func TestCheckPassword_Invalid(t *testing.T) {}	assert.NoError(t, err)	err := CheckPassword(password, hash)	hash, _ := HashPassword(password)	password := "SecurePassword123!"func TestCheckPassword_Valid(t *testing.T) {}	assert.NoError(t, err)	err = CheckPassword(password, hash)	// Verify hash is valid	assert.NotEqual(t, password, hash)	assert.NotEmpty(t, hash)	assert.NoError(t, err)	hash, err := HashPassword(password)	password := "SecurePassword123!"func TestHashPassword(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.NoError(t, err)	err := repo.UpdateLastLogin(ctx, id)		WillReturnResult(sqlmock.NewResult(0, 1))		WithArgs(sqlmock.AnyArg(), id).	mock.ExpectExec("UPDATE administrative_employees").	id := "test-id"	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestUpdateLastLogin_Success(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.Contains(t, err.Error(), "employee not found")	assert.Error(t, err)	err := repo.Delete(ctx, id)		WillReturnResult(sqlmock.NewResult(0, 0))		WithArgs(sqlmock.AnyArg(), id).	mock.ExpectExec("UPDATE administrative_employees").	id := "non-existent-id"	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestDelete_NotFound(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.NoError(t, err)	err := repo.Delete(ctx, id)		WillReturnResult(sqlmock.NewResult(0, 1))		WithArgs(sqlmock.AnyArg(), id).	mock.ExpectExec("UPDATE administrative_employees").	id := "test-id"	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestDelete_Success(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.Contains(t, err.Error(), "employee not found")	assert.Error(t, err)	err := repo.UpdatePassword(ctx, id, passwordHash)		WillReturnResult(sqlmock.NewResult(0, 0))		WithArgs(passwordHash, sqlmock.AnyArg(), id).	mock.ExpectExec("UPDATE administrative_employees").	passwordHash := "newhashedpassword"	id := "non-existent-id"	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestUpdatePassword_NotFound(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.NoError(t, err)	err := repo.UpdatePassword(ctx, id, passwordHash)		WillReturnResult(sqlmock.NewResult(0, 1))		WithArgs(passwordHash, sqlmock.AnyArg(), id).	mock.ExpectExec("UPDATE administrative_employees").	passwordHash := "newhashedpassword"	id := "test-id"	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestUpdatePassword_Success(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.Contains(t, err.Error(), "employee not found")	assert.Error(t, err)	err := repo.Update(ctx, id, employee)		WillReturnResult(sqlmock.NewResult(0, 0))		).			id,			sqlmock.AnyArg(),			employee.IsActive,			employee.Role,			employee.LastName,			employee.FirstName,			employee.Email,		WithArgs(	mock.ExpectExec("UPDATE administrative_employees").	}		IsActive:  true,		Role:      "admin",		LastName:  "Smith",		FirstName: "Jane",		Email:     "updated@example.com",	employee := &models.AdministrativeEmployee{	id := "non-existent-id"	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestUpdate_NotFound(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.NotZero(t, employee.UpdatedAt)	assert.NoError(t, err)	err := repo.Update(ctx, id, employee)		WillReturnResult(sqlmock.NewResult(0, 1))		).			id,			sqlmock.AnyArg(), // UpdatedAt			employee.IsActive,			employee.Role,			employee.LastName,			employee.FirstName,			employee.Email,		WithArgs(	mock.ExpectExec("UPDATE administrative_employees").	}		IsActive:  true,		Role:      "admin",		LastName:  "Smith",		FirstName: "Jane",		Email:     "updated@example.com",	employee := &models.AdministrativeEmployee{	id := "test-id"	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestUpdate_Success(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.Len(t, employees, 0)	employees := result.Items.([]*models.AdministrativeEmployee)	assert.Equal(t, 0, result.TotalCount)	assert.NotNil(t, result)	assert.NoError(t, err)	result, err := repo.GetAll(ctx, filters)		WillReturnRows(rows)		WithArgs(10, 0).	mock.ExpectQuery("SELECT (.+) FROM administrative_employees").	})		"created_at", "updated_at", "last_login_at",		"id", "email", "first_name", "last_name", "role", "is_active",	rows := sqlmock.NewRows([]string{	// Expect data query		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(0))	mock.ExpectQuery("SELECT COUNT\\(\\*\\) FROM administrative_employees").	// Expect count query	}		Limit: 10,		Page:  1,	filters := EmployeeFilters{	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestGetAll_EmptyResult(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.Equal(t, 3, result.TotalPages) // 15 / 5 = 3	assert.Equal(t, 2, result.Page)	assert.Equal(t, 15, result.TotalCount)	assert.NotNil(t, result)	assert.NoError(t, err)	result, err := repo.GetAll(ctx, filters)		WillReturnRows(rows)		WithArgs(5, 5). // limit, offset	mock.ExpectQuery("SELECT (.+) FROM administrative_employees").	})		"created_at", "updated_at", "last_login_at",		"id", "email", "first_name", "last_name", "role", "is_active",	rows := sqlmock.NewRows([]string{	// Expect data query with correct offset		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(15))	mock.ExpectQuery("SELECT COUNT\\(\\*\\) FROM administrative_employees").	// Expect count query	}		Limit: 5,		Page:  2,	filters := EmployeeFilters{	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestGetAll_Pagination(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.Len(t, employees, 2)	employees := result.Items.([]*models.AdministrativeEmployee)	assert.Equal(t, 1, result.TotalPages)	assert.Equal(t, 10, result.Limit)	assert.Equal(t, 1, result.Page)	assert.Equal(t, 2, result.TotalCount)	assert.NotNil(t, result)	assert.NoError(t, err)	result, err := repo.GetAll(ctx, filters)		WillReturnRows(rows)		WithArgs(isActive, "admin", "%John%", 10, 0).	mock.ExpectQuery("SELECT (.+) FROM administrative_employees").		AddRow("id2", "john2@example.com", "John", "Smith", "admin", true, now, now, nil)		AddRow("id1", "john1@example.com", "John", "Doe", "admin", true, now, now, now).	}).		"created_at", "updated_at", "last_login_at",		"id", "email", "first_name", "last_name", "role", "is_active",	rows := sqlmock.NewRows([]string{	now := time.Now()	// Expect data query		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(2))		WithArgs(isActive, "admin", "%John%").	mock.ExpectQuery("SELECT COUNT\\(\\*\\) FROM administrative_employees").	// Expect count query	}		SortDesc: false,		SortBy:   "last_name",		Limit:    10,		Page:     1,		Search:   "John",		Role:     "admin",		IsActive: &isActive,	filters := EmployeeFilters{	isActive := true	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestGetAll_WithFilters(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.NotNil(t, employee)	assert.NoError(t, err)	employee, err := repo.GetByEmail(ctx, email)		WillReturnRows(rows)		WithArgs(email).	mock.ExpectQuery("SELECT (.+) FROM administrative_employees WHERE LOWER\\(email\\)").	)		now, now, nil,		"test-id", "test@example.com", "hashedpassword", "John", "Doe", "admin", true,	}).AddRow(		"created_at", "updated_at", "last_login_at",		"id", "email", "password_hash", "first_name", "last_name", "role", "is_active",	rows := sqlmock.NewRows([]string{	now := time.Now()	email := "Test@EXAMPLE.COM"	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestGetByEmail_CaseInsensitive(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.Nil(t, employee.LastLoginAt)	assert.Equal(t, "hashedpassword", employee.PasswordHash)	assert.Equal(t, email, employee.Email)	assert.NotNil(t, employee)	assert.NoError(t, err)	employee, err := repo.GetByEmail(ctx, email)		WillReturnRows(rows)		WithArgs(email).	mock.ExpectQuery("SELECT (.+) FROM administrative_employees WHERE LOWER\\(email\\)").	)		now, now, nil,		"test-id", email, "hashedpassword", "John", "Doe", "admin", true,	}).AddRow(		"created_at", "updated_at", "last_login_at",		"id", "email", "password_hash", "first_name", "last_name", "role", "is_active",	rows := sqlmock.NewRows([]string{	now := time.Now()	email := "test@example.com"	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestGetByEmail_Success(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.Contains(t, err.Error(), "employee not found")	assert.Nil(t, employee)	assert.Error(t, err)	employee, err := repo.GetByID(ctx, id)		WillReturnError(sql.ErrNoRows)		WithArgs(id).	mock.ExpectQuery("SELECT (.+) FROM administrative_employees WHERE id").	id := "non-existent-id"	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestGetByID_NotFound(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.NotNil(t, employee.LastLoginAt)	assert.Equal(t, "Doe", employee.LastName)	assert.Equal(t, "John", employee.FirstName)	assert.Equal(t, "test@example.com", employee.Email)	assert.Equal(t, id, employee.ID)	assert.NotNil(t, employee)	assert.NoError(t, err)	employee, err := repo.GetByID(ctx, id)		WillReturnRows(rows)		WithArgs(id).	mock.ExpectQuery("SELECT (.+) FROM administrative_employees WHERE id").	)		now, now, now,		id, "test@example.com", "John", "Doe", "admin", true,	}).AddRow(		"created_at", "updated_at", "last_login_at",		"id", "email", "first_name", "last_name", "role", "is_active",	rows := sqlmock.NewRows([]string{	now := time.Now()	id := "test-id"	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestGetByID_Success(t *testing.T) {}	assert.Error(t, err)	err := repo.Create(ctx, employee)		WillReturnError(sql.ErrConnDone) // Simulating duplicate key error		).			sqlmock.AnyArg(),			sqlmock.AnyArg(),			employee.IsActive,			employee.Role,			employee.LastName,			employee.FirstName,			employee.PasswordHash,			employee.Email,			sqlmock.AnyArg(),		WithArgs(	mock.ExpectExec("INSERT INTO administrative_employees").	}		IsActive:     true,		Role:         "admin",		LastName:     "Doe",		FirstName:    "Jane",		PasswordHash: "hashedpassword",		Email:        "existing@example.com",	employee := &models.AdministrativeEmployee{	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestCreate_DuplicateEmail(t *testing.T) {}	assert.NoError(t, mock.ExpectationsWereMet())	assert.NotZero(t, employee.UpdatedAt)	assert.NotZero(t, employee.CreatedAt)	assert.NotEmpty(t, employee.ID)	assert.NoError(t, err)	err := repo.Create(ctx, employee)		WillReturnResult(sqlmock.NewResult(1, 1))		).			sqlmock.AnyArg(), // UpdatedAt			sqlmock.AnyArg(), // CreatedAt			employee.IsActive,			employee.Role,			employee.LastName,			employee.FirstName,			employee.PasswordHash,			employee.Email,			sqlmock.AnyArg(), // ID (UUID)		WithArgs(	mock.ExpectExec("INSERT INTO administrative_employees").	}		IsActive:     true,		Role:         "admin",		LastName:     "Doe",		FirstName:    "John",		PasswordHash: "hashedpassword",		Email:        "test@example.com",	employee := &models.AdministrativeEmployee{	ctx := context.Background()	defer db.Close()	db, mock, repo := setupTestDB(t)func TestCreate_Success(t *testing.T) {}	return db, mock, repo	repo := NewUserRepository(db)	require.NoError(t, err)	db, mock, err := sqlmock.New()func setupTestDB(t *testing.T) (*sql.DB, sqlmock.Sqlmock, *UserRepository) {)	"github.com/stretchr/testify/require"	"github.com/stretchr/testify/assert"	"github.com/goldenkiwi/autoparc/internal/models"	"github.com/DATA-DOG/go-sqlmock"