package service
package service

import (
	"context"
	"fmt"
	"testing"
















































































































































































































































































































































































































































































































































































}	mockUserRepo.AssertExpectations(t)	assert.Error(t, err)	err := service.DeleteEmployee(ctx, id, "admin-id")	mockUserRepo.On("GetByID", ctx, id).Return(nil, fmt.Errorf("employee not found"))	id := "550e8400-e29b-41d4-a716-446655440000"	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestDeleteEmployee_NotFound(t *testing.T) {}	assert.Contains(t, err.Error(), "invalid employee ID format")	assert.Error(t, err)	err := service.DeleteEmployee(ctx, id, "admin-id")	id := "invalid-uuid"	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestDeleteEmployee_InvalidUUID(t *testing.T) {}	mockActionRepo.AssertExpectations(t)	mockUserRepo.AssertExpectations(t)	assert.NoError(t, err)	err := service.DeleteEmployee(ctx, id, "admin-id")	mockActionRepo.On("Create", ctx, mock.AnythingOfType("*models.ActionLog")).Return(nil)	mockUserRepo.On("Delete", ctx, id).Return(nil)	mockUserRepo.On("GetByID", ctx, id).Return(employee, nil)	}		IsActive: true,		Email:    "test@example.com",		ID:       id,	employee := &models.AdministrativeEmployee{	id := "550e8400-e29b-41d4-a716-446655440000"	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestDeleteEmployee_Success(t *testing.T) {}	mockUserRepo.AssertExpectations(t)	assert.Contains(t, err.Error(), "email already exists")	assert.Nil(t, resp)	assert.Error(t, err)	resp, err := service.UpdateEmployee(ctx, id, req, "admin-id")	mockUserRepo.On("GetByEmail", ctx, req.Email).Return(anotherEmployee, nil)	mockUserRepo.On("GetByID", ctx, id).Return(existingEmployee, nil)	}		Email: "taken@example.com",	req := UpdateEmployeeRequest{	}		Email: "taken@example.com",		ID:    "another-id",	anotherEmployee := &models.AdministrativeEmployee{	}		LastName:  "Doe",		FirstName: "John",		Email:     "old@example.com",		ID:        id,	existingEmployee := &models.AdministrativeEmployee{	id := "550e8400-e29b-41d4-a716-446655440000"	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestUpdateEmployee_DuplicateEmail(t *testing.T) {}	assert.Contains(t, err.Error(), "invalid employee ID format")	assert.Nil(t, resp)	assert.Error(t, err)	resp, err := service.UpdateEmployee(ctx, id, req, "admin-id")	}		Email: "new@example.com",	req := UpdateEmployeeRequest{	id := "invalid-uuid"	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestUpdateEmployee_InvalidUUID(t *testing.T) {}	mockActionRepo.AssertExpectations(t)	mockUserRepo.AssertExpectations(t)	assert.Equal(t, "Smith", resp.LastName)	assert.Equal(t, "Jane", resp.FirstName)	assert.Equal(t, "new@example.com", resp.Email)	assert.NotNil(t, resp)	assert.NoError(t, err)	resp, err := service.UpdateEmployee(ctx, id, req, "admin-id")	mockActionRepo.On("Create", ctx, mock.AnythingOfType("*models.ActionLog")).Return(nil)	mockUserRepo.On("Update", ctx, id, mock.AnythingOfType("*models.AdministrativeEmployee")).Return(nil)	mockUserRepo.On("GetByEmail", ctx, req.Email).Return(nil, fmt.Errorf("not found"))	mockUserRepo.On("GetByID", ctx, id).Return(existingEmployee, nil)	}		LastName:  "Smith",		FirstName: "Jane",		Email:     "new@example.com",	req := UpdateEmployeeRequest{	}		UpdatedAt: time.Now(),		CreatedAt: time.Now(),		IsActive:  true,		Role:      "admin",		LastName:  "Doe",		FirstName: "John",		Email:     "old@example.com",		ID:        id,	existingEmployee := &models.AdministrativeEmployee{	id := "550e8400-e29b-41d4-a716-446655440000"	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestUpdateEmployee_Success(t *testing.T) {}	mockUserRepo.AssertExpectations(t)	assert.Equal(t, 20, resp.Limit)	assert.Equal(t, 1, resp.Page)	assert.NotNil(t, resp)	assert.NoError(t, err)	resp, err := service.GetEmployees(ctx, filters)	})).Return(paginationResult, nil)		return f.Page == 1 && f.Limit == 20	mockUserRepo.On("GetAll", ctx, mock.MatchedBy(func(f repository.EmployeeFilters) bool {	}		TotalPages: 0,		Limit:      20,		Page:       1,		TotalCount: 0,		Items:      []*models.AdministrativeEmployee{},	paginationResult := &repository.PaginationResult{	}		Limit: 200, // Too high, should default to 20		Page:  0, // Invalid, should default to 1	filters := repository.EmployeeFilters{	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestGetEmployees_DefaultPagination(t *testing.T) {}	mockUserRepo.AssertExpectations(t)	assert.Equal(t, 1, resp.TotalPages)	assert.Equal(t, 1, resp.Page)	assert.Equal(t, 2, resp.TotalCount)	assert.Len(t, resp.Employees, 2)	assert.NotNil(t, resp)	assert.NoError(t, err)	resp, err := service.GetEmployees(ctx, filters)	})).Return(paginationResult, nil)		return f.Page == 1 && f.Limit == 10	mockUserRepo.On("GetAll", ctx, mock.MatchedBy(func(f repository.EmployeeFilters) bool {	}		TotalPages: 1,		Limit:      10,		Page:       1,		TotalCount: 2,		Items:      employees,	paginationResult := &repository.PaginationResult{	}		{ID: "id2", Email: "user2@example.com", FirstName: "Jane", LastName: "Smith"},		{ID: "id1", Email: "user1@example.com", FirstName: "John", LastName: "Doe"},	employees := []*models.AdministrativeEmployee{	}		Limit: 10,		Page:  1,	filters := repository.EmployeeFilters{	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestGetEmployees_Success(t *testing.T) {}	mockUserRepo.AssertExpectations(t)	assert.Nil(t, resp)	assert.Error(t, err)	resp, err := service.GetEmployee(ctx, id)	mockUserRepo.On("GetByID", ctx, id).Return(nil, fmt.Errorf("employee not found"))	id := "550e8400-e29b-41d4-a716-446655440000"	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestGetEmployee_NotFound(t *testing.T) {}	assert.Contains(t, err.Error(), "invalid employee ID format")	assert.Nil(t, resp)	assert.Error(t, err)	resp, err := service.GetEmployee(ctx, id)	id := "invalid-uuid"	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestGetEmployee_InvalidUUID(t *testing.T) {}	mockUserRepo.AssertExpectations(t)	assert.Equal(t, "test@example.com", resp.Email)	assert.Equal(t, id, resp.ID)	assert.NotNil(t, resp)	assert.NoError(t, err)	resp, err := service.GetEmployee(ctx, id)	mockUserRepo.On("GetByID", ctx, id).Return(employee, nil)	}		IsActive:  true,		Role:      "admin",		LastName:  "Doe",		FirstName: "John",		Email:     "test@example.com",		ID:        id,	employee := &models.AdministrativeEmployee{	id := "550e8400-e29b-41d4-a716-446655440000"	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestGetEmployee_Success(t *testing.T) {}	assert.Contains(t, err.Error(), "first name is required")	assert.Nil(t, resp)	assert.Error(t, err)	resp, err := service.CreateEmployee(ctx, req, "admin-id")	mockUserRepo.On("GetByEmail", ctx, req.Email).Return(nil, fmt.Errorf("not found"))	}		LastName:  "Doe",		FirstName: "",		Password:  "SecurePass123",		Email:     "new@example.com",	req := CreateEmployeeRequest{	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestCreateEmployee_MissingFirstName(t *testing.T) {}	assert.Contains(t, err.Error(), "password must be at least 8 characters")	assert.Nil(t, resp)	assert.Error(t, err)	resp, err := service.CreateEmployee(ctx, req, "admin-id")	mockUserRepo.On("GetByEmail", ctx, req.Email).Return(nil, fmt.Errorf("not found"))	}		LastName:  "Doe",		FirstName: "John",		Password:  "weak",		Email:     "new@example.com",	req := CreateEmployeeRequest{	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestCreateEmployee_WeakPassword(t *testing.T) {}	mockUserRepo.AssertExpectations(t)	assert.Contains(t, err.Error(), "email already exists")	assert.Nil(t, resp)	assert.Error(t, err)	resp, err := service.CreateEmployee(ctx, req, "admin-id")	mockUserRepo.On("GetByEmail", ctx, req.Email).Return(existingEmployee, nil)	}		Email: "existing@example.com",		ID:    "existing-id",	existingEmployee := &models.AdministrativeEmployee{	}		LastName:  "Doe",		FirstName: "John",		Password:  "SecurePass123",		Email:     "existing@example.com",	req := CreateEmployeeRequest{	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestCreateEmployee_DuplicateEmail(t *testing.T) {}	assert.Contains(t, err.Error(), "invalid email format")	assert.Nil(t, resp)	assert.Error(t, err)	resp, err := service.CreateEmployee(ctx, req, "admin-id")	}		LastName:  "Doe",		FirstName: "John",		Password:  "SecurePass123",		Email:     "invalid-email",	req := CreateEmployeeRequest{	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestCreateEmployee_InvalidEmail(t *testing.T) {}	mockActionRepo.AssertExpectations(t)	mockUserRepo.AssertExpectations(t)	assert.Empty(t, resp.PasswordHash, "password hash should not be returned")	assert.True(t, resp.IsActive)	assert.Equal(t, "Doe", resp.LastName)	assert.Equal(t, "John", resp.FirstName)	assert.Equal(t, "new@example.com", resp.Email)	assert.NotNil(t, resp)	assert.NoError(t, err)	resp, err := service.CreateEmployee(ctx, req, "admin-id")	mockActionRepo.On("Create", ctx, mock.AnythingOfType("*models.ActionLog")).Return(nil)	// Mock action log	mockUserRepo.On("Create", ctx, mock.AnythingOfType("*models.AdministrativeEmployee")).Return(nil)	// Mock create	mockUserRepo.On("GetByEmail", ctx, req.Email).Return(nil, fmt.Errorf("not found"))	// Mock email check - not exists	}		Role:      "admin",		LastName:  "Doe",		FirstName: "John",		Password:  "SecurePass123",		Email:     "new@example.com",	req := CreateEmployeeRequest{	ctx := context.Background()	service := NewEmployeeService(mockUserRepo, mockActionRepo)	mockActionRepo := new(MockActionLogRepository)	mockUserRepo := new(MockUserRepository)func TestCreateEmployee_Success(t *testing.T) {}	}		})			}				assert.NoError(t, err)			} else {				assert.Error(t, err)			if tt.wantErr {			err := ValidatePasswordStrength(tt.password)		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		{"empty password", "", true},		{"no numbers", "PasswordSecure", true},		{"no lowercase", "PASSWORD123", true},		{"no uppercase", "password123", true},		{"too short", "Pass1", true},		{"valid with special chars", "Secure@Pass123!", false},		{"valid strong password", "SecurePass123", false},	}{		wantErr  bool		password string		name     string	tests := []struct {func TestValidatePasswordStrength(t *testing.T) {}	}		})			}				assert.NoError(t, err)			} else {				assert.Error(t, err)			if tt.wantErr {			err := ValidateEmail(tt.email)		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		{"invalid format - spaces", "test @example.com", true},		{"invalid format - no TLD", "test@example", true},		{"invalid format - no domain", "test@", true},		{"invalid format - no @", "testexample.com", true},		{"empty email", "", true},		{"valid email with plus", "user+tag@example.com", false},		{"valid email with subdomain", "user@mail.example.com", false},		{"valid email", "test@example.com", false},	}{		wantErr bool		email   string		name    string	tests := []struct {func TestValidateEmail(t *testing.T) {}	return args.Get(0).([]*models.ActionLog), args.Int(1), args.Error(2)	}		return nil, args.Int(1), args.Error(2)	if args.Get(0) == nil {	args := m.Called(ctx, page, limit)func (m *MockActionLogRepository) GetAll(ctx context.Context, page, limit int) ([]*models.ActionLog, int, error) {}	return args.Get(0).([]*models.ActionLog), args.Int(1), args.Error(2)	}		return nil, args.Int(1), args.Error(2)	if args.Get(0) == nil {	args := m.Called(ctx, entityType, entityID, page, limit)func (m *MockActionLogRepository) GetByEntityID(ctx context.Context, entityType, entityID string, page, limit int) ([]*models.ActionLog, int, error) {}	return args.Error(0)	args := m.Called(ctx, actionLog)func (m *MockActionLogRepository) Create(ctx context.Context, actionLog *models.ActionLog) error {}	mock.Mocktype MockActionLogRepository struct {// MockActionLogRepository is a mock implementation of ActionLogRepository}	return args.Error(0)	args := m.Called(ctx, id)func (m *MockUserRepository) UpdateLastLogin(ctx context.Context, id string) error {}	return args.Get(0).(*models.AdministrativeEmployee), args.Error(1)	}		return nil, args.Error(1)	if args.Get(0) == nil {	args := m.Called(ctx, id)func (m *MockUserRepository) FindByID(ctx context.Context, id string) (*models.AdministrativeEmployee, error) {}	return args.Get(0).(*models.AdministrativeEmployee), args.Error(1)	}		return nil, args.Error(1)	if args.Get(0) == nil {	args := m.Called(ctx, email)func (m *MockUserRepository) FindByEmail(ctx context.Context, email string) (*models.AdministrativeEmployee, error) {}	return args.Error(0)	args := m.Called(ctx, id)func (m *MockUserRepository) Delete(ctx context.Context, id string) error {}	return args.Error(0)	args := m.Called(ctx, id, passwordHash)func (m *MockUserRepository) UpdatePassword(ctx context.Context, id string, passwordHash string) error {}	return args.Error(0)	args := m.Called(ctx, id, employee)func (m *MockUserRepository) Update(ctx context.Context, id string, employee *models.AdministrativeEmployee) error {}	return args.Get(0).(*repository.PaginationResult), args.Error(1)	}		return nil, args.Error(1)	if args.Get(0) == nil {	args := m.Called(ctx, filters)func (m *MockUserRepository) GetAll(ctx context.Context, filters repository.EmployeeFilters) (*repository.PaginationResult, error) {}	return args.Get(0).(*models.AdministrativeEmployee), args.Error(1)	}		return nil, args.Error(1)	if args.Get(0) == nil {	args := m.Called(ctx, email)func (m *MockUserRepository) GetByEmail(ctx context.Context, email string) (*models.AdministrativeEmployee, error) {}	return args.Get(0).(*models.AdministrativeEmployee), args.Error(1)	}		return nil, args.Error(1)	if args.Get(0) == nil {	args := m.Called(ctx, id)func (m *MockUserRepository) GetByID(ctx context.Context, id string) (*models.AdministrativeEmployee, error) {}	return args.Error(0)	args := m.Called(ctx, employee)func (m *MockUserRepository) Create(ctx context.Context, employee *models.AdministrativeEmployee) error {}	mock.Mocktype MockUserRepository struct {// MockUserRepository is a mock implementation of UserRepository)	"github.com/stretchr/testify/mock"	"github.com/stretchr/testify/assert"	"github.com/goldenkiwi/autoparc/internal/repository"	"github.com/goldenkiwi/autoparc/internal/models"	"time"